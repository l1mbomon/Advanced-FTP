## To Run

`bash$ make cleanall`\
`bash$ make demo`

## Introduction

A greater understanding of the standard network stack and various internet protocols has
provided an opportunity for the team of NC State University graduate students listed above to
design and develop a solution for cloud storage systems. This solution will allow enterprises to
configure any number of client hosts to automatically sync file artifacts to a configured remote
server. The team is focused on optimizing network communication between hosts to provide two
key benefits. First, to reduce network bandwidth utilization by minimizing redundant file
transfers. Second, to allow the prioritization of certain file directories; enabling specific artifacts
to be backed up with greater network priority, reducing the risk of potential client data loss
during transmission. This proposal will describe how to provide these benefits, the current
design of the solution, and how we plan to evaluate and demonstrate the finished product.

## Problem Statement

The majority of data used and stored in various enterprise environments is represented as
files. This empowers (Simple) File Transfer Protocols (S)FTP to satisfy data storage
requirements even at a large scale. The general scenario this solution pertains to is one where an
enterprise requires many clients to synchronize file system data to one or few central servers
used for backup storage. Based on one’s configuration, the central data could be shared and
updated by various clients. However, by default, each client would their own personal storage
space reserved. Regardless, enterprise data, which is generated by a multitude of employees or
systems, is managed most easily from one or few locations. In addition, we understand business
critical data will require higher priority when being synchronized. This solution will backup file
data so to avoid any loss in the event of client failures. However, because the data is copied over
a network, there will be an inherent latency from the time the data is originally created, and when
the data has been completely copied to the remote server. This delay creates a window where the
data is vulnerable to being lost. Therefore, artifacts which are deemed more critical will
minimize this window by being prioritized during network communication.

## Objectives

● The overall objective is to allow many clients to send new or updated files to a central
  server. Creating a system where organizations can consolidate data from multiple unix
  computers, into one or few.
  #### FTP Client Objectives
  ○ User configuration determines the top level directory to “watch”\
  ○ Everything included in this directory will be synced as-is to the central server on a
    configured periodic basis.\
  ○ Users can provide different top level directories with individual or common ranks.\
  ○ Files sent by the client will be prioritized by order of rank.\
  ○ Files will be read at configured segment sizes, where a checksum is then generated
    for each segment.\
  ○ The client communicates over HTTP/REST to the server to determine if the file
    exists, and if so, determines if any segments have the same checksum and position as
    what is recorded.\
  ○ If the segment already exists, skip. Otherwise, send.
  #### FTP Server Objectives
  ○ User configuration determines the top level directory to “store”\
  ○ Everything received by clients will be stored in client-specific directories underneath
    the “store” directory.\
  ○ Maintain a light-weight database containing file, checksum, client, and system
    information.\
  ○ User configuration allows clients of certain names to have ranks. Clients default to
    lowest priority.\
  ○ Respond to client HTTP/REST requests to initiate new clients, and respond to file
    queries based on the current state of database.\
  ○ Accept new connections from known clients for receiving file segments.\
  ○ Receive and apply file segments in order of client rank.
  
● Both the client and server objectives shall be achieved through Python/Unix applications.
User configuration will be applied at startup, then the applications may run autonomously
as long as the host system is active.
